import torchmetrics
import torch
import argparse
from pathlib import Path
import pickle
from malgen.infra.imagedata import ImageDataModule
from malgen.infra.classifier import Classifier
from tqdm import tqdm


def torch_fidelity_metrics(generated, real):
    import torch_fidelity
    return torch_fidelity.calculate_metrics(
        input1=generated,
        input2=real,
        cuda=True,
        isc=True,
        fid=True,
        kid=True,
        prc=True,
        ppl=True,
        verbose=False,
    )


@torch.inference_mode()
def classification_metrics(classifier, dataloader, one_hot=True):
    dataset_predictions = []
    dataset_labels = []
    for images, labels in tqdm(dataloader):
        # each image should have a binary label vector
        # one-hot should only be False for the control (real vs real)
        predictions = classifier(images)

        # if it's one-hot, every prediction other than for that label
        # will be ignored
        if one_hot:
            predictions *= labels
            predictions = predictions.max(0).values
            # because we only keep the positive label, ROC is not as useful
            labels = torch.ones(labels.shape[0])

        dataset_predictions.append(predictions)
        dataset_labels.append(labels)
    dataset_predictions = torch.cat(dataset_predictions)
    dataset_labels = torch.cat(dataset_labels)
    accuracy = torchmetrics.Accuracy(task="binary")
    f1 = torchmetrics.F1Score(task="binary")
    precision = torchmetrics.Precision(task="binary")
    recall = torchmetrics.Recall(task="binary")
    return {
        "accuracy": accuracy(dataset_predictions, dataset_labels),
        "f1": f1(dataset_predictions, dataset_labels),
        "precision": precision(dataset_predictions, dataset_labels),
        "recall": recall(dataset_predictions, dataset_labels),
    }


def all_metrics(trainset, valset, genset, classifier_t, classifier_v, classifier_g):
    metrics = torch_fidelity_metrics(trainset, genset)

    # GAN-test
    gan_test = classification_metrics(classifier_t, genset)
    metrics["GAN-test"] = gan_test

    # Neural network divergence
    nnd = classification_metrics(classifier_v, genset)
    metrics["Neural network divergence"] = nnd

    # Compute control outside (no relation to genset)

    # GAN-train
    gan_train = classification_metrics(classifier_g, valset)
    metrics["GAN-train"] = gan_train

    return metrics


# train on training set
# test on validation set (control)
# train on validation set


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-tr", "--train_dir")
    parser.add_argument("-va", "--va_dir")
    parser.add_argument("-ge", "--gen_dir")
    subparsers = parser.add_subparsers(dest="sub")
    tfm_parser = subparsers.add_parser("tfm", help="Get Torch fidelity metrics")
    cls_parser = subparsers.add_parser("cls", help="Get classification metrics")
    cls_parser.add_argument(
        "-cls", "--classifier", help="Path to classifier checkpoint", required=True
    )
    cls_parser.add_argument(
        "-b", "--batch_size", help="Batch size", default=16, type=int
    )
    cls_parser.add_argument(
        "-m",
        "--multi_label",
        help="Whether to evaluate all labels per sample for classification metrics",
        action=argparse.BooleanOptionalAction,
    )
    args = parser.parse_args()
    print(args)
    if args.sub == "tfm":
        metrics = torch_fidelity_metrics(args.gen_dir, args.train_dir)
        print(metrics)
        with open(f"tfm-{Path(args.gen_dir).name}.pkl") as f:
            pickle.dump(metrics, f)
    elif args.sub == "cls":
        datamod = ImageDataModule(val_dir=args.val_dir, bucket=False)
        dataloader = datamod.val_dataloader()
        cls = Classifier.load_from_checkpoint(cls_parser.classifier)
        metrics = classification_metrics(cls, dataloader, not cls_parser.multi_label)
        print(metrics)
        with open(f"cls-{Path(args.val_dir).name}.pkl") as f:
            pickle.dump(metrics, f)
    else:
        print(f"Command {args.sub} unrecognized")
        parser.print_help()
