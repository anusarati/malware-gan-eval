import torch_fidelity
import torchmetrics
import lightning as L
import torch
from torch.utils.data import DataLoader
import os


def torch_fidelity_metrics(real, generated):
    return torch_fidelity.calculate_metrics(
        input1=real,
        input2=generated,
        cuda=True,
        isc=True,
        fid=True,
        kid=True,
        prc=True,
        ppl=True,
        verbose=False,
    )


@torch.inference_mode()
def classification_metrics(classifier, dataset, one_hot=True):
    dataset_predictions = []
    dataset_labels = []
    dataloader = get_dataloader(dataset)
    for images, labels in dataloader:
        # each image should have a binary label vector
        # one-hot should only be False for the control (real vs real)
        predictions = classifier(images)

        # if it's one-hot, every prediction other than for that label
        # will be ignored
        if one_hot:
            predictions *= labels
            predictions = predictions.max(0).values
            # because we only keep the positive label, ROC is not as useful
            labels = torch.ones(labels.shape[0])

        dataset_predictions.append(predictions)
        dataset_labels.append(labels)
    dataset_predictions = torch.cat(dataset_predictions)
    dataset_labels = torch.cat(dataset_labels)
    accuracy = torchmetrics.Accuracy(task="binary")
    f1 = torchmetrics.F1Score(task="binary")
    precision = torchmetrics.Precision(task="binary")
    recall = torchmetrics.Recall(task="binary")
    return {
        "accuracy": accuracy(dataset_predictions, dataset_labels),
        "f1": f1(dataset_predictions, dataset_labels),
        "precision": precision(dataset_predictions, dataset_labels),
        "recall": recall(dataset_predictions, dataset_labels),
    }


def all_metrics(trainset, valset, genset, classifier_t, classifier_v, classifier_g):
    metrics = torch_fidelity_metrics(trainset, genset)

    # GAN-test
    gan_test = classification_metrics(classifier_t, genset)
    metrics["GAN-test"] = gan_test

    # Neural network divergence
    nnd = classification_metrics(classifier_v, genset)
    metrics["Neural network divergence"] = nnd

    # Compute control outside (no relation to genset)

    # GAN-train
    gan_train = classification_metrics(classifier_g, valset)
    metrics["GAN-train"] = gan_train

    return metrics


# train on training set
# test on validation set (control)
# train on validation set
