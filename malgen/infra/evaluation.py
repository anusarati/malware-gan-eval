import torch_fidelity
import torchmetrics
import torch
import argparse
from pathlib import Path
import pickle


def torch_fidelity_metrics(generated, real):
    return torch_fidelity.calculate_metrics(
        input1=generated,
        input2=real,
        cuda=True,
        isc=True,
        fid=True,
        kid=True,
        prc=True,
        ppl=True,
        verbose=False,
    )


@torch.inference_mode()
def classification_metrics(classifier, dataloader, one_hot=True):
    dataset_predictions = []
    dataset_labels = []
    for images, labels in dataloader:
        # each image should have a binary label vector
        # one-hot should only be False for the control (real vs real)
        predictions = classifier(images)

        # if it's one-hot, every prediction other than for that label
        # will be ignored
        if one_hot:
            predictions *= labels
            predictions = predictions.max(0).values
            # because we only keep the positive label, ROC is not as useful
            labels = torch.ones(labels.shape[0])

        dataset_predictions.append(predictions)
        dataset_labels.append(labels)
    dataset_predictions = torch.cat(dataset_predictions)
    dataset_labels = torch.cat(dataset_labels)
    accuracy = torchmetrics.Accuracy(task="binary")
    f1 = torchmetrics.F1Score(task="binary")
    precision = torchmetrics.Precision(task="binary")
    recall = torchmetrics.Recall(task="binary")
    return {
        "accuracy": accuracy(dataset_predictions, dataset_labels),
        "f1": f1(dataset_predictions, dataset_labels),
        "precision": precision(dataset_predictions, dataset_labels),
        "recall": recall(dataset_predictions, dataset_labels),
    }


def all_metrics(trainset, valset, genset, classifier_t, classifier_v, classifier_g):
    metrics = torch_fidelity_metrics(trainset, genset)

    # GAN-test
    gan_test = classification_metrics(classifier_t, genset)
    metrics["GAN-test"] = gan_test

    # Neural network divergence
    nnd = classification_metrics(classifier_v, genset)
    metrics["Neural network divergence"] = nnd

    # Compute control outside (no relation to genset)

    # GAN-train
    gan_train = classification_metrics(classifier_g, valset)
    metrics["GAN-train"] = gan_train

    return metrics


# train on training set
# test on validation set (control)
# train on validation set


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(["-tr", "--train_dir"])
    parser.add_argument(["-va", "--va_dir"])
    parser.add_argument(["-ge", "--gen_dir"])
    subparsers = parser.add_subparsers(dest="sub")
    tfm_parser = subparsers.add_parser("tfm", help="Get Torch fidelity metrics")
    args = tfm_parser.parse_args()
    print(args)
    if args.sub == "tfm":
        metrics = torch_fidelity_metrics(args.gen_dir, args.train_dir)
        with open(f"tfm-{Path(args.gen_dir).name}.pkl") as f:
            pickle.dump(metrics, f)
    else:
        print(f"Command {args.sub} unrecognized")
        parser.print_help()
