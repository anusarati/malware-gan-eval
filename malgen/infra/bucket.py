"""Put images into buckets of the same size"""

import argparse
from pathlib import Path
import pickle
import bisect
import torch
from PIL import Image
from threading import Lock
import os
from torchvision.transforms import v2, InterpolationMode
from tqdm.contrib.concurrent import thread_map
from math import ceil


def bucket(idir, rank, world_size, outdir, min_bucket_size):

    idir = Path(idir)
    with open(idir / "sizefreqs.pkl", "rb") as f:
        sizefreqs = pickle.load(f)
    bucket_sizes = [64, 512]
    for size, freq in sizefreqs.items():
        if 64 < size and size < 512 and freq >= min_bucket_size:
            bucket_sizes.append(size)
    bucket_sizes = sorted(bucket_sizes)
    bucket_size_set = frozenset(bucket_sizes)
    image_buckets = {}
    lock = Lock()

    paths = list(filter(lambda p: p.suffix != ".pkl", idir.iterdir()))

    n_per_node = ceil(len(paths) / world_size)
    assigned = paths[n_per_node * rank : n_per_node * (rank + 1)]

    def assign_bucket(path):
        if path.suffix == ".pt":
            img = torch.load(path)
            size = img.shape[-1]
        else:
            img = Image.open(path)
            size = img.size[0]
        outpath = outdir / path.name
        if size in bucket_size_set:
            os.symlink(path, outpath)
        else:
            point = bisect.bisect_left(bucket_sizes, size)
            closest_size = bucket_sizes[point] if point < len(bucket_sizes) else 512
            if path.suffix == ".pt":
                img = v2.functional.resize(
                    img,
                    (closest_size, closest_size),
                    interpolation=InterpolationMode.BICUBIC,
                )
                torch.save(img, outpath)
            else:
                img = img.resize((closest_size, closest_size))
                img.save(outpath)
            size = closest_size
        with lock:
            image_buckets[path.name] = size

    thread_map(assign_bucket, assigned)

    with open(outdir / f"_bucket-{rank}.pkl", "wb") as f:
        pickle.dump(image_buckets, f)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-rank", type=int, required=True)
    parser.add_argument("-i", "--dir", type=str, required=True)
    parser.add_argument("-size", required=True)
    parser.add_argument("-world_size", type=int, required=True)
    parser.add_argument("-o", "--out", type=str, required=True)
    parser.add_argument(
        ["-b", "--bucket"],
        type=str,
        required=True,
        help="The minimum number of images in each bucket",
    )
    args = parser.parse_args()
    print(args, flush=True)
    bucket(
        idir=args.dir,
        rank=args.rank,
        world_size=args.world_size,
        outdir=args.out if args.out else ".",
        min_bucket_size=args.bucket,
    )
