"""Prepares most of an image dataset folder for StyleGAN using distributed computing"""

from vis import visualize
import pandas as pd
from pathlib import Path
from malgen.infra.constants import CATEGORIES
import argparse
import pickle
from math import ceil
from tqdm.contrib.concurrent import thread_map
import torch
from torchvision.transforms import v2
import os
from threading import Lock


def organize_images(idir, size, mode, rank, world_size, base_out, duplicate_folder):
    device = "cuda" if torch.cuda.is_available() else "cpu"

    idir = Path(idir)
    df = pd.read_pickle(idir / "meta.pkl")
    df = df[list(("sha256",) + CATEGORIES)]
    outdir = Path(base_out) / str(size) / mode
    (outdir / category).mkdir(parents=True, exist_ok=True)
    if duplicate_folder:
        for category in CATEGORIES:
            (outdir / category).mkdir(parents=True, exist_ok=True)
    labels = [] if duplicate_folder else {}
    label_lock = Lock()

    n_rows = df.shape[0]
    n_per_node = ceil(n_rows / world_size)

    df = df.iloc[n_per_node * rank : n_per_node * (rank + 1)]

    def save_image(img, outpath):
        if os.path.isfile(outpath):
            return True
        if mode == "embed":
            torch.save(img.to("cpu"), outpath)
        else:
            img.save(outpath)
        return False

    def organize_image(entry):
        nonlocal labels
        filename = entry.sha256
        if mode == "embed":
            filename += ".pt"
        filepath = idir / filename

        if mode == "embed":
            img = torch.load(filepath, map_location=device)
            img = v2.functional.resize(img, (img.shape[0], size, size))
        else:
            img = visualize(filepath=filepath, mode=mode)
            if size != "original":
                img = img.resize((size, size))

        if mode != "embed":
            filename += ".png"

        if duplicate_folder:
            for i, category in enumerate(CATEGORIES):
                if entry.__getattribute__(category) >= 1:
                    relpath = Path(category) / filename
                    outpath = outdir / relpath
                    if save_image(img, outpath):
                        return
                    with label_lock:
                        labels.append([str(relpath), i])
        else:
            class_ids = [
                i
                for i, category in enumerate(CATEGORIES)
                if entry.__getattribute__(category) >= 1
            ]
            with label_lock:
                labels[filename] = class_ids
            save_image(img, outdir / filename)

    thread_map(
        organize_image,
        df.itertuples(),
        total=min(n_per_node, n_rows - n_per_node * rank),
    )

    with open(outdir / f"_labels{rank}.pkl", "wb") as pkl_file:
        pickle.dump(labels, pkl_file)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-rank", type=int)
    parser.add_argument("-dir", type=str, required=True)
    parser.add_argument("-size", required=True)
    parser.add_argument("-world_size", type=int)
    parser.add_argument("-mode", type=str)
    parser.add_argument("-out", type=str, required=True)
    parser.add_argument("-duplicate_folder", action=argparse.BooleanOptionalAction)
    args = parser.parse_args()
    if args.size != "original":
        args.size = int(args.size)
    print(args, flush=True)
    organize_images(
        idir=args.dir,
        size=args.size,
        mode=args.mode,
        rank=args.rank,
        world_size=args.world_size,
        base_out=args.out if args.out else ".",
        duplicate_folder=args.duplicate_folder,
    )
