"""Prepares most of an image dataset folder for StyleGAN using distributed computing"""

from vis import visualize
import pandas as pd
from pathlib import Path
from malgen.infra.constants import CATEGORIES
import argparse
import pickle
from math import ceil
from tqdm.contrib.concurrent import thread_map
import torch
from torchvision.transforms import v2
import os
from threading import Lock
from malgen.bin_vis.embedding.embed import embed
from malgen.bin_vis.embedding.color import RGBProjector


def label(idir, rank, world_size):
    idir = Path(idir)
    df = pd.read_pickle(idir / "meta.pkl")
    df = df[list(("sha256",) + CATEGORIES)]

    labels = {}
    label_lock = Lock()

    n_rows = df.shape[0]
    n_per_node = ceil(n_rows / world_size)

    df = df.iloc[n_per_node * rank : n_per_node * (rank + 1)]

    def _label(filename):
        nonlocal labels
        filepath = idir / filename
        if os.path.isfile(filepath):
            class_ids = [
                i
                for i, category in enumerate(CATEGORIES)
                if filename.__getattribute__(category) >= 1
            ]
            with label_lock:
                labels[filename] = class_ids

    thread_map(
        _label,
        df["sha256"].values,
        total=min(n_per_node, n_rows - n_per_node * rank),
    )

    with open(idir / f"_labels{rank}.pkl", "wb") as pkl_file:
        pickle.dump(labels, pkl_file)


def organize_images(
    idir, size, mode, rank, world_size, base_out, duplicate_folder, rem=False
):
    idir = Path(idir)
    df = pd.read_pickle(idir / "meta.pkl")
    df = df[list(("sha256",) + CATEGORIES)]

    if rem:
        with open("rem.txt") as f:
            lines = f.readlines()
            paths = map(str.strip, lines)
            paths = map(Path, paths)
            hashes = set(map(lambda p: p.name, paths))
            df = df.query("sha256 in @hashes")

    outdir = Path(base_out) / str(size) / mode
    outdir.mkdir(parents=True, exist_ok=True)
    if duplicate_folder:
        for category in CATEGORIES:
            (outdir / category).mkdir(parents=True, exist_ok=True)
        (outdir / "master").mkdir(parents=True, exist_ok=True)
    labels = [] if duplicate_folder else {}
    label_lock = Lock()

    n_rows = df.shape[0]
    n_per_node = ceil(n_rows / world_size)

    df = df.iloc[n_per_node * rank : n_per_node * (rank + 1)]

    rgbproj = torch.load("rgbproj.pkl") if mode == "embed" else None

    def save_image(img, outpath):
        if os.path.isfile(outpath):
            return True
        img.save(outpath)
        return False

    def organize_image(entry):
        nonlocal labels
        filename = entry.sha256
        filepath = idir / filename

        if mode == "embed":
            img = embed(filepath=filepath)
            img = rgbproj.pil(img)
        else:
            img = visualize(filepath=filepath, mode=mode)

        if size != "original":
            img = img.resize((size, size))

        filename += ".png"

        if duplicate_folder:
            master_path = outdir / "master" / filename
            save_image(img, master_path)
            for i, category in enumerate(CATEGORIES):
                if entry.__getattribute__(category) >= 1:
                    relpath = Path(category) / filename
                    outpath = outdir / relpath
                    os.link(master_path, outpath)
                    with label_lock:
                        labels.append([str(relpath), i])
        else:
            class_ids = [
                i
                for i, category in enumerate(CATEGORIES)
                if entry.__getattribute__(category) >= 1
            ]
            with label_lock:
                labels[filename] = class_ids
            save_image(img, outdir / filename)

    thread_map(
        organize_image,
        df.itertuples(),
        total=min(n_per_node, n_rows - n_per_node * rank),
    )

    with open(outdir / f"_labels{rank}.pkl", "wb") as pkl_file:
        pickle.dump(labels, pkl_file)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-rank", type=int)
    parser.add_argument("-dir", type=str, required=True)
    parser.add_argument("-size", required=True)
    parser.add_argument("-world_size", type=int)
    parser.add_argument("-mode", type=str)
    parser.add_argument("-out", type=str, required=True)
    parser.add_argument("-duplicate_folder", action=argparse.BooleanOptionalAction)
    parser.add_argument("-rem", action=argparse.BooleanOptionalAction)
    parser.add_argument("-label", action=argparse.BooleanOptionalAction)
    args = parser.parse_args()
    if args.size != "original":
        args.size = int(args.size)
    print(args, flush=True)
    if args.label:
        label(idir=args.dir, rank=args.rank, world_size=args.world_size)
    else:
        organize_images(
            idir=args.dir,
            size=args.size,
            mode=args.mode,
            rank=args.rank,
            world_size=args.world_size,
            base_out=args.out if args.out else ".",
            duplicate_folder=args.duplicate_folder,
            rem=args.rem,
        )
